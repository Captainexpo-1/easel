---
title: Orpheus writes a parser
order: 3
---

Ok. We have a bunch of nice tokens now.

Our lexer produces a bunch of tokens, but we still can't do much with them quite yet. The next step to solving this problem is to write a *parser*, which will turn our currently rather one-dimensional list of tokens into what's known as an *abstract syntax tree*.

## Abstract syntax trees

Orpheus drew a diagram for us last chapter on how lexers turn a blob of text that's meant to be our program into a list of tokens.

Parsers take these tokens and in turn output a tree of sorts that describes how tokens apply to one another. Here's an example of such an transformation:

<LexerParserTransform/>

We took five tokens and smooshed them into one *node*. The five tokens described the syntax of our program but the node describes what the syntax actually does - creates a variable with a value of 50!

We're going to write that parser now. It's actually, surprisingly, similar to how we wrote our lexer, except that we're working with a tree now, which means we'll need some form of recursion. 

Let's start with the usual! Orpheus opens a file called `parser.js` and throw this in there:

```js
export class Parser {
  constructor(tokens) {
    this.tokens = tokens
    this.ast = []
    this.current = 0
  }

  error(token, msg) {
    throw new Error(`${token.line}:${token.column}: ${msg}`)
  }
}
```

Based on the diagram, the most intuitive next step is to loop through every token that we get. Let's do that in our `parse()` method:

```js
export class Parser {
  // ...

  parse() {
    while (this.peekType() !== TOKENS.EOF) continue; // TODO
    return this.ast
  }
}
```

This is pretty similar to our `scanTokens()` method in our lexer, but last time, we dealt with each character at a time. Tokens have more information then that - we also get a token's type - so we have two helper `peek()` methods this time instead of one:

```js
export class Parser {
  // ...

  peek() {
    if (this.current >= this.tokens.length) return null
    return this.tokens[this.current]
  }

  peekType() {
    if (this.current >= this.tokens.length) return null
    return this.tokens[this.current].type
  }

  parse() {
    // ...
  }
}
```

Cool! Now, what exactly do with these tokens?

## Recursive descent

With our lexer, we looped through every character and checked if it could be a token or belong to set of characters that would belong to a token. Here, we're going to do something different - we're going to define a grammar for what our program could look like and work our way up until we can describe an entire chunk of code.

First up: what do these have in similar?

<img src="/cartoons/types.png" style={{ width: "40%" }}/>

<aside>Like Froot Loop chunks sitting in Orpheus' stomach. Protests Orpheus: they're the best cereal to exist.</aside>

Orpheus has an answer! *They're all super basic.* They're what we'll call **literals** - we can't really break them down further, or they'd just be unintelligible chunks that we can't use, and they also happen to be the most basic values we can reference.

To give an exact definition we'll reference later when writing our parser, literals in Easel can be: strings, numbers, or booleans.

Ok, what's the next obvious step from here? I'm thinking like arrays, or data types that build off literals by collecting them and storing them together. In Easel, it's quite simple - I can think of two data types and those are arrays and structs (or maps or whatever you want to call them. Orpheus decided to stick to structs while editing this, although that might not semantically be the best.)

I bet you already have ideas forming in your head on how to parse these. Arrays? LeftBracket &rarr; parse stuff in between &rarr; RightBracket.

But let's not get too far ahead of ourselves yet. What is this stuff "in between"? 

<aside>
  Or 0th item.
</aside>

Well, I imagine we might have an array that looks like `[2 + 3, 5, 7]`. That first item in the array is not a literal anymore. It's a binary expression!

<img src="/cartoons/binop.png" style={{ width: "25%" }}/>

So things are kind of coming together now. Literals can form expressions. We don't just have to form binary expressions - we can also form *unary* ones. Bet those are more rare, but surely you've seen them before: the NOT operator `!true`, for example.

Ok. So we know literals can form expressions. What can expressions form? It turns out almost everything else we can think of, especially for a language like Easel. This is because everything else is a *statement* - a set of expressions. Let's see:

<aside>
  For-loops and while loops and Fruit Loops are all the same thing really. For-loops are basically while loops in Easel, where the condition is that the number is between two numbers.
</aside>

* Variables. Specifically, assignment! `prepare phoneVolume as 50` is assigning a literal (see what I did there?) to a variable.
* Structs. Specifically, defining what a struct looks like. `brush Phone has { phoneVolume }` is a statement.
* Functions are blocks of expressions with attached metadata of sorts, like what arguments we might need to pass in!
* Return statements
* For loops and while loops are blocks of expressions also with attached metadata too, like what condition we should check for every iteration.
* Last but not least in Easel - if-else statements are blocks of expressions with, you guessed it, attached metadata like what conditions we shoud check for.

Our job now is to write a parser that can understand this hierarchy. The parser will start by looking for statements, which are made of expressions, which are made of literals. In other words: basic recursive descent! 

## Back to writing code

Ok! Sturp talking! Let's get to smacking the keyboard instead. By then, it should be pretty obvious that we'll need another utility method we're desparately missing: the good ole' `eat` method for eating tokens up:

```js
class Parser {
  // ...
  
  eat(type) {
    if (this.peekType() === type) return this.tokens[this.current++]
    this.error(
      this.peek(),
      `Expected ${type} but got ${this.peekType().toString()}`
    )
  }
  
  // ...
}
```

<aside>
  At this point we're going to stop putting the class definition around each method or Orpheus is going to have to start writing on napkins soon.
</aside>

Welp, looks like we need an error method too:

```js
error(token, msg) {
  throw new Error(`${token.line}:${token.column}: ${msg}`)
}
```

Now let's begin our descent... into the <strike>underworld</strike> writing of a parser! Let's start with this basic structure:

```js
class Parser {
  simple() {

  }

  expr() {
    let left = this.simple()
    // Let's deal with the right side later
    return left
  }

  stmt() {
    case next = this.peek() 
    switch (next.type) {
      // Can you guess what's coming here later?
      default:
        return this.expr()
    }
  }
}
```

Ok, understandable enough! Although this isn't going to do anything right now. Let's fix that by updating `simple()`:

```js
simple() {
  let token = this.eat(this.peekType())
  switch (token.type) {
    case TOKENS.String:
    case TOKENS.Number:
    case TOKENS.Boolean:
      return new Ast.Literal(token.content)
  }
  this.error(token, "Expected expression but got " + token)
}
```

Notice how we throw an error if we don't get anything. Since this is the last method we reach when we're looking at a token, there must be a *syntax error* if we can't get a proper node.

Something we didn't consider ahead of time was how we would define how these nodes look like. We'll do this really easily. Let's create a new file called `ast.js`, and put our first kind of node in there:

```js
export class Literal {
  constructor(value) {
    this.type = 'Literal'
    this.value = value
  }
}

export default {
  Literal
}
```

Make sure to import this in `parser.js`!

```js
import Ast from "./ast.js";
```

Perfect. Back to `simple()` now - we're also going to add arrays as a literal too just because it's simple and JavaScript is one of those languages where we don't have to worry about type anyways:

```js
simple() {
  let token = this.eat(this.peekType())
  switch (token.type) {
    // ...
    case TOKENS.LeftBracket:
      let items = []
      if (this.peekType() !== TOKENS.RightBracket) items = this.exprList()
      this.eat(TOKENS.RightBracket)
      return new Ast.Literal(items)
  }
  this.error(token, "Expected expression but got " + token)
}
```

<aside>
  You've got to thank Orpheus for this, she was smart and decided it would be useful to have a separate method because we'd use it again in the future. And she was right.
</aside>

Our predictions were correct. We gobble up the left bracket, create a new array, and if we haven't already reached the right bracket (i.e. empty array), we grab the list of expressions in between.

Now, we make use of an extra helper called `exprList()` to do this.

```js
exprList() {
  let exprs = []
  exprs.push(this.expr())
  while (this.peekType() === TOKENS.Comma) {
    this.eat(TOKENS.Comma)
    exprs.push(this.expr())
  }
  return exprs
}
```

One last thing we'll add for now to `simple()` is:

```js
simple() {
  // ...
  switch (token.type) {
    // ...
    case TOKENS.Identifier:
        return new Ast.Var(token.value)
  }
}
```

This might confuse you a bit - didn't we say variables were statements? Yes, but this is not that - this is referring to when we reference a variable, not direct assignment.

This does make use of a new kind of node though, so let's add that to `ast.js`:

```js
export class Var {
  constructor(name, value) {
    this.type = 'Var'
    this.name = name
    this.value = value
  }
}

export default {
  // ...
  Var
}
```

Cool. That takes care of `simple()` for now. Let's move up the hierarchy and tweak `expr()`! Right now, we've only grabbed the left side of what should be a binary operation. Let's grab the operator and the right side after that:

```js
expr() {
  // expr has two sides
  let left = this.call()
  if (isOp(this.peekType())) {
    const op = this.eat(this.peekType()).value
    let right = this.expr()
    return new Ast.Binary(left, op, right)
  }
  return left
}
```

Looks like we need an extra `isOp` function. I'll put this at the top of `parser.js`:

```js
const isOp = type => {
  return [
    TOKENS.Or,
    TOKENS.And,
    TOKENS.Equiv,
    TOKENS.NotEquiv,
    TOKENS.Gt,
    TOKENS.Gte,
    TOKENS.Lt,
    TOKENS.Lte,
    TOKENS.Plus,
    TOKENS.Minus,
    TOKENS.Asterisk,
    TOKENS.Slash
  ].includes(type)
}
```

Our binary expression node is pretty simple:

```js
export class Binary {
  constructor(left, operator, right) {
    this.type = "Binary"
    this.left = left
    this.operator = operator
    this.right = right
  }
}

export default {
  // ...
  Binary
}
```

Ok, I think we've got enough here where we can test the parser out and see what happens. We should, of course, start using our parser in `easel.js`:


```js
import { Parser } from './parser.js'

// ...

if (location) {
  const program = await readFile(location)

  const lexer = new Lexer(program)
  try {
    lexer.scanTokens()
  } catch (err) {
    // Only log errors thrown by our lexer
    if (err instanceof EaselError) console.log(err)
  } finally {
    if (debug) await writeFile('tokens.json', JSON.stringify(lexer.tokens))
  }

  const parser = new Parser(lexer.tokens)
  try {
    parser.parse()
  } catch (err) {
    // Only log errors thrown by our parser
    if (err instanceof EaselError) console.log
  } finally {
    if (debug) await writeFile('ast.json', JSON.stringify(parser.ast))
  }
} 
// ...
```

Cool! Let's test this out with a test program:

```js
[4 + 21]
2006 / 4012 + 2
```

It's not really a complete program because we haven't taken care of statements yet, but I digress. You'll get something like this `ast.json`:

<aside>
  Yours probably looks like a mumble-jumble in one line. I use [Prettier](https://prettier.io/docs/en/install), but fun fact - you can also try `JSON.stringify(parser.ast, null, 2)`.
</aside>

```js
[
  {
    "type": "Literal",
    "value": [
      {
        "type": "Binary",
        "left": { "type": "Literal", "value": 4 },
        "operator": "+",
        "right": { "type": "Literal", "value": 21 }
      }
    ]
  },
  {
    "type": "Binary",
    "left": { "type": "Literal", "value": 2006 },
    "operator": "/",
    "right": {
      "type": "Binary",
      "left": { "type": "Literal", "value": 4012 },
      "operator": "+",
      "right": { "type": "Literal", "value": 2 }
    }
  }
]
```

This looks right, but there's just one minor problem... if we run that second node, this is what we get:

<img src="/cartoons/pemdas.png" style={{ width: "50%" }} />

### Dealing with order of operations

<aside>
  Orpheus needs an acronym.
</aside>

Oopsies. We forgot about PEMDAS. We should fix that. Never fear! Orpheus has put on her wizard hat and come up with a rather ingenious way to tackle this.

First things first, all operators should have a precedence hierarchy. If I see an addition operator and a multiplication operator in the same expression, then I should combine the operators next to the multiplication operator first before moving onto the addition operator. But if we've already parsed the addition operator, we can do a little switcheroo. Orpheus wants to show you what she means by this. Read the following in what you might imagine to be her voice.

First things first, at the top of `parser.js`!

```js
const opOrder = {
  '+': 0,
  '-': 0,
  '*': 1,
  '/': 1,
  '||': 1,
  '&&': 1,
  '==': 1,
  '!=': 1,
  '>': 1,
  '>=': 1,
  '<': 1,
  '<=': 1
}
```

Next, I am going to add a little if-statement that checks if `right` is also a binary expression node, and compare the operators if so:

```js
expr() {
  // expr has two sides
  let left = this.call()
  if (isOp(this.peekType())) {
    const op = this.eat(this.peekType()).value
    let right = this.expr()
    if (right instanceof Ast.Binary && opOrder[op] > opOrder[right.operator])
      // Quick reordering based on precedence
      return new Ast.Binary(
        new Ast.Binary(left, op, right.left),
        right.operator,
        right.right
      )
    return new Ast.Binary(left, op, right)
  }
  return left
}
```

Ok. Back to me. I'll take the mic back. Thanks. [grabs mic]

And that fixes all our problems! Well, not all of our problems, of course. We still have a few more things left to do until our parser is fully functional. Let's move onto the big leagues now!

## Statements

<aside>
  If you feel like you need to take a break, take one! I think Orpheus is slightly mad at me so she's left to go eat Indian food and talk about Berlin with her friends.
</aside>

Ok, awesome cool. Statements. Statements! Let's take care of that now.

```js
const assignStmt = () => {
  this.eatKeyword('prepare')
  const name = this.eat(TOKENS.Identifier).value
  if (this.peekType() === TOKENS.Period) {
    // Setter
    this.eat(TOKENS.Period)
    const property = this.eat(TOKENS.Identifier).value
    this.eatKeyword('as')
    const value = this.expr()
    return new Ast.Set(name, property, value)
  }
  this.eatKeyword('as')
  const value = this.expr()
  return new Ast.Var(name, value)
}
```

### What about calls?

Bring, bling! Bring, bring!

I think that's Orpheus' phone ringing. She's going to answer it.

I think Orpheus knows a little more than we've been let onto. Is that what was up with all the, uh, phone-related examples earlier? Probs.

It's our mysterious benefactor, just reminding us about... calls? OH! Calls

## Unary operators

There's just one last token we haven't accounted for. I'll give you a moment to think about it. Which token could we possibly be forgetting about?

The NOT operator! That's right - our only unary operator. We haven't dealt with unary operators yet. Let's take care of that now.

Let's test out everything we have so far. Try running `node easel.js test.easel --dbg`, and you'll get a new debug file containing the AST in `ast.json`. Mine looks something like this:

<aside>
  We've crimped it because it is rather long. It's like that one time Orpheus tried to print a program out but it accidentally came out on the sticker printer. Let's just say it was more than a few feet long.
</aside>

<details>
  <summary>`ast.json</summary>

```json
[
  {
    "type": "Var",
    "name": "rows",
    "value": { "type": "Literal", "value": 50 }
  },
  {
    "type": "Var",
    "name": "cols",
    "value": { "type": "Literal", "value": 20 }
  },
  { "type": "Struct", "name": "Cell", "members": ["x", "y", "live"] },
  {
    "type": "Func",
    "name": "seed",
    "params": [],
    "body": [
      {
        "type": "Var",
        "name": "cells",
        "value": { "type": "Array", "value": [] }
      },
      {
        "type": "For",
        "id": "x",
        "range": [
          { "type": "Literal", "value": 0 },
          { "type": "Var", "name": "rows" }
        ],
        "body": [
          {
            "type": "For",
            "id": "y",
            "range": [
              { "type": "Literal", "value": 0 },
              { "type": "Var", "name": "cols" }
            ],
            "body": [
              {
                "type": "Var",
                "name": "live",
                "value": { "type": "Literal", "value": false }
              },
              {
                "type": "Var",
                "name": "chance",
                "value": {
                  "type": "Call",
                  "caller": { "type": "Var", "name": "random" },
                  "args": [
                    { "type": "Literal", "value": 0 },
                    { "type": "Literal", "value": 100 }
                  ]
                }
              },
              {
                "type": "Conditional",
                "condition": {
                  "type": "Binary",
                  "left": { "type": "Var", "name": "chance" },
                  "operator": "<",
                  "right": { "type": "Literal", "value": 20 }
                },
                "body": [
                  {
                    "type": "Var",
                    "name": "live",
                    "value": { "type": "Literal", "value": true }
                  }
                ],
                "otherwise": []
              },
              {
                "type": "Call",
                "caller": {
                  "type": "Get",
                  "caller": { "type": "Var", "name": "cells" },
                  "property": "add",
                  "isExpr": false
                },
                "args": [
                  {
                    "type": "Instance",
                    "name": "Cell",
                    "members": {
                      "x": { "type": "Var", "name": "x" },
                      "y": { "type": "Var", "name": "y" },
                      "live": { "type": "Var", "name": "live" }
                    }
                  }
                ]
              }
            ]
          }
        ]
      },
      { "type": "Return", "value": { "type": "Var", "name": "cells" } }
    ]
  },
  {
    "type": "Var",
    "name": "cells",
    "value": {
      "type": "Call",
      "caller": { "type": "Var", "name": "seed" },
      "args": []
    }
  },
  {
    "type": "Func",
    "name": "getNeighbors",
    "params": ["cells", "index"],
    "body": [
      {
        "type": "Var",
        "name": "neighbors",
        "value": { "type": "Array", "value": [] }
      },
      {
        "type": "Conditional",
        "condition": {
          "type": "Binary",
          "left": {
            "type": "Binary",
            "left": { "type": "Var", "name": "index" },
            "operator": "-",
            "right": {
              "type": "Binary",
              "left": { "type": "Var", "name": "rows" },
              "operator": "-",
              "right": { "type": "Literal", "value": 1 }
            }
          },
          "operator": ">",
          "right": { "type": "Literal", "value": 0 }
        },
        "body": [
          {
            "type": "Call",
            "caller": {
              "type": "Get",
              "caller": { "type": "Var", "name": "neighbors" },
              "property": "add",
              "isExpr": false
            },
            "args": [
              {
                "type": "Get",
                "caller": { "type": "Var", "name": "cells" },
                "property": {
                  "type": "Binary",
                  "left": { "type": "Var", "name": "index" },
                  "operator": "-",
                  "right": {
                    "type": "Binary",
                    "left": { "type": "Var", "name": "rows" },
                    "operator": "-",
                    "right": { "type": "Literal", "value": 1 }
                  }
                },
                "isExpr": true
              }
            ]
          }
        ],
        "otherwise": []
      },
      {
        "type": "Conditional",
        "condition": {
          "type": "Binary",
          "left": {
            "type": "Binary",
            "left": { "type": "Var", "name": "index" },
            "operator": "-",
            "right": { "type": "Var", "name": "rows" }
          },
          "operator": ">",
          "right": { "type": "Literal", "value": 0 }
        },
        "body": [
          {
            "type": "Call",
            "caller": {
              "type": "Get",
              "caller": { "type": "Var", "name": "neighbors" },
              "property": "add",
              "isExpr": false
            },
            "args": [
              {
                "type": "Get",
                "caller": { "type": "Var", "name": "cells" },
                "property": {
                  "type": "Binary",
                  "left": { "type": "Var", "name": "index" },
                  "operator": "-",
                  "right": { "type": "Var", "name": "rows" }
                },
                "isExpr": true
              }
            ]
          }
        ],
        "otherwise": []
      },
      {
        "type": "Conditional",
        "condition": {
          "type": "Binary",
          "left": {
            "type": "Binary",
            "left": { "type": "Var", "name": "index" },
            "operator": "-",
            "right": {
              "type": "Binary",
              "left": { "type": "Var", "name": "rows" },
              "operator": "+",
              "right": { "type": "Literal", "value": 1 }
            }
          },
          "operator": ">",
          "right": { "type": "Literal", "value": 0 }
        },
        "body": [
          {
            "type": "Call",
            "caller": {
              "type": "Get",
              "caller": { "type": "Var", "name": "neighbors" },
              "property": "add",
              "isExpr": false
            },
            "args": [
              {
                "type": "Get",
                "caller": { "type": "Var", "name": "cells" },
                "property": {
                  "type": "Binary",
                  "left": { "type": "Var", "name": "index" },
                  "operator": "-",
                  "right": {
                    "type": "Binary",
                    "left": { "type": "Var", "name": "rows" },
                    "operator": "+",
                    "right": { "type": "Literal", "value": 1 }
                  }
                },
                "isExpr": true
              }
            ]
          }
        ],
        "otherwise": []
      },
      {
        "type": "Conditional",
        "condition": {
          "type": "Binary",
          "left": { "type": "Var", "name": "index" },
          "operator": ">",
          "right": { "type": "Literal", "value": 0 }
        },
        "body": [
          {
            "type": "Call",
            "caller": {
              "type": "Get",
              "caller": { "type": "Var", "name": "neighbors" },
              "property": "add",
              "isExpr": false
            },
            "args": [
              {
                "type": "Get",
                "caller": { "type": "Var", "name": "cells" },
                "property": {
                  "type": "Binary",
                  "left": { "type": "Var", "name": "index" },
                  "operator": "-",
                  "right": { "type": "Literal", "value": 1 }
                },
                "isExpr": true
              }
            ]
          }
        ],
        "otherwise": []
      },
      {
        "type": "Conditional",
        "condition": {
          "type": "Binary",
          "left": { "type": "Var", "name": "index" },
          "operator": "<",
          "right": {
            "type": "Binary",
            "left": {
              "type": "Get",
              "caller": { "type": "Var", "name": "cells" },
              "property": "length",
              "isExpr": false
            },
            "operator": "-",
            "right": { "type": "Literal", "value": 1 }
          }
        },
        "body": [
          {
            "type": "Call",
            "caller": {
              "type": "Get",
              "caller": { "type": "Var", "name": "neighbors" },
              "property": "add",
              "isExpr": false
            },
            "args": [
              {
                "type": "Get",
                "caller": { "type": "Var", "name": "cells" },
                "property": {
                  "type": "Binary",
                  "left": { "type": "Var", "name": "index" },
                  "operator": "+",
                  "right": { "type": "Literal", "value": 1 }
                },
                "isExpr": true
              }
            ]
          }
        ],
        "otherwise": []
      },
      {
        "type": "Conditional",
        "condition": {
          "type": "Binary",
          "left": {
            "type": "Binary",
            "left": { "type": "Var", "name": "index" },
            "operator": "+",
            "right": {
              "type": "Binary",
              "left": { "type": "Var", "name": "rows" },
              "operator": "-",
              "right": { "type": "Literal", "value": 1 }
            }
          },
          "operator": "<",
          "right": {
            "type": "Binary",
            "left": {
              "type": "Get",
              "caller": { "type": "Var", "name": "cells" },
              "property": "length",
              "isExpr": false
            },
            "operator": "-",
            "right": { "type": "Literal", "value": 1 }
          }
        },
        "body": [
          {
            "type": "Call",
            "caller": {
              "type": "Get",
              "caller": { "type": "Var", "name": "neighbors" },
              "property": "add",
              "isExpr": false
            },
            "args": [
              {
                "type": "Get",
                "caller": { "type": "Var", "name": "cells" },
                "property": {
                  "type": "Binary",
                  "left": { "type": "Var", "name": "index" },
                  "operator": "+",
                  "right": {
                    "type": "Binary",
                    "left": { "type": "Var", "name": "rows" },
                    "operator": "-",
                    "right": { "type": "Literal", "value": 1 }
                  }
                },
                "isExpr": true
              }
            ]
          }
        ],
        "otherwise": []
      },
      {
        "type": "Conditional",
        "condition": {
          "type": "Binary",
          "left": {
            "type": "Binary",
            "left": { "type": "Var", "name": "index" },
            "operator": "+",
            "right": { "type": "Var", "name": "rows" }
          },
          "operator": "<",
          "right": {
            "type": "Binary",
            "left": {
              "type": "Get",
              "caller": { "type": "Var", "name": "cells" },
              "property": "length",
              "isExpr": false
            },
            "operator": "-",
            "right": { "type": "Literal", "value": 1 }
          }
        },
        "body": [
          {
            "type": "Call",
            "caller": {
              "type": "Get",
              "caller": { "type": "Var", "name": "neighbors" },
              "property": "add",
              "isExpr": false
            },
            "args": [
              {
                "type": "Get",
                "caller": { "type": "Var", "name": "cells" },
                "property": {
                  "type": "Binary",
                  "left": { "type": "Var", "name": "index" },
                  "operator": "+",
                  "right": { "type": "Literal", "value": 1 }
                },
                "isExpr": true
              }
            ]
          }
        ],
        "otherwise": []
      },
      {
        "type": "Conditional",
        "condition": {
          "type": "Binary",
          "left": {
            "type": "Binary",
            "left": { "type": "Var", "name": "index" },
            "operator": "+",
            "right": {
              "type": "Binary",
              "left": { "type": "Var", "name": "rows" },
              "operator": "+",
              "right": { "type": "Literal", "value": 1 }
            }
          },
          "operator": "<",
          "right": {
            "type": "Binary",
            "left": {
              "type": "Get",
              "caller": { "type": "Var", "name": "cells" },
              "property": "length",
              "isExpr": false
            },
            "operator": "-",
            "right": { "type": "Literal", "value": 1 }
          }
        },
        "body": [
          {
            "type": "Call",
            "caller": {
              "type": "Get",
              "caller": { "type": "Var", "name": "neighbors" },
              "property": "add",
              "isExpr": false
            },
            "args": [
              {
                "type": "Get",
                "caller": { "type": "Var", "name": "cells" },
                "property": {
                  "type": "Binary",
                  "left": { "type": "Var", "name": "index" },
                  "operator": "+",
                  "right": {
                    "type": "Binary",
                    "left": { "type": "Var", "name": "rows" },
                    "operator": "-",
                    "right": { "type": "Literal", "value": 1 }
                  }
                },
                "isExpr": true
              }
            ]
          }
        ],
        "otherwise": []
      },
      {
        "type": "Var",
        "name": "alive",
        "value": { "type": "Array", "value": [] }
      },
      {
        "type": "For",
        "id": "i",
        "range": [
          { "type": "Literal", "value": 0 },
          {
            "type": "Get",
            "caller": { "type": "Var", "name": "neighbors" },
            "property": "length",
            "isExpr": false
          }
        ],
        "body": [
          {
            "type": "Conditional",
            "condition": {
              "type": "Get",
              "caller": {
                "type": "Get",
                "caller": { "type": "Var", "name": "neighbors" },
                "property": { "type": "Var", "name": "i" },
                "isExpr": true
              },
              "property": "live",
              "isExpr": false
            },
            "body": [
              {
                "type": "Call",
                "caller": {
                  "type": "Get",
                  "caller": { "type": "Var", "name": "alive" },
                  "property": "add",
                  "isExpr": false
                },
                "args": [
                  {
                    "type": "Get",
                    "caller": { "type": "Var", "name": "neighbors" },
                    "property": { "type": "Var", "name": "i" },
                    "isExpr": true
                  }
                ]
              }
            ],
            "otherwise": []
          }
        ]
      },
      { "type": "Return", "value": { "type": "Var", "name": "alive" } }
    ]
  },
  {
    "type": "Func",
    "name": "painting",
    "params": [],
    "body": [
      {
        "type": "For",
        "id": "i",
        "range": [
          { "type": "Literal", "value": 0 },
          {
            "type": "Get",
            "caller": { "type": "Var", "name": "cells" },
            "property": "length",
            "isExpr": false
          }
        ],
        "body": [
          {
            "type": "Var",
            "name": "cell",
            "value": {
              "type": "Get",
              "caller": { "type": "Var", "name": "cells" },
              "property": { "type": "Var", "name": "i" },
              "isExpr": true
            }
          },
          {
            "type": "Var",
            "name": "neighbors",
            "value": {
              "type": "Call",
              "caller": { "type": "Var", "name": "getNeighbors" },
              "args": [
                { "type": "Var", "name": "cells" },
                { "type": "Var", "name": "i" }
              ]
            }
          },
          {
            "type": "Conditional",
            "condition": {
              "type": "Get",
              "caller": { "type": "Var", "name": "cell" },
              "property": "live",
              "isExpr": false
            },
            "body": [
              {
                "type": "Conditional",
                "condition": {
                  "type": "Binary",
                  "left": {
                    "type": "Get",
                    "caller": { "type": "Var", "name": "neighbors" },
                    "property": "length",
                    "isExpr": false
                  },
                  "operator": "<",
                  "right": {
                    "type": "Binary",
                    "left": { "type": "Literal", "value": 2 },
                    "operator": "||",
                    "right": {
                      "type": "Binary",
                      "left": {
                        "type": "Get",
                        "caller": { "type": "Var", "name": "neighbors" },
                        "property": "length",
                        "isExpr": false
                      },
                      "operator": ">",
                      "right": { "type": "Literal", "value": 3 }
                    }
                  }
                },
                "body": [
                  {
                    "type": "Set",
                    "caller": "cell",
                    "property": "live",
                    "value": { "type": "Literal", "value": false }
                  }
                ],
                "otherwise": [
                  {
                    "type": "Conditional",
                    "condition": {
                      "type": "Unary",
                      "operator": "!",
                      "apply": {
                        "type": "Binary",
                        "left": {
                          "type": "Get",
                          "caller": { "type": "Var", "name": "cell" },
                          "property": "live",
                          "isExpr": false
                        },
                        "operator": "&&",
                        "right": {
                          "type": "Binary",
                          "left": { "type": "Var", "name": "neighbors" },
                          "operator": "==",
                          "right": { "type": "Literal", "value": 3 }
                        }
                      }
                    },
                    "body": [
                      {
                        "type": "Set",
                        "caller": "cell",
                        "property": "live",
                        "value": { "type": "Literal", "value": true }
                      }
                    ],
                    "otherwise": []
                  }
                ]
              }
            ],
            "otherwise": []
          },
          {
            "type": "Conditional",
            "condition": {
              "type": "Get",
              "caller": { "type": "Var", "name": "cell" },
              "property": "live",
              "isExpr": false
            },
            "body": [
              {
                "type": "Var",
                "name": "color",
                "value": {
                  "type": "Instance",
                  "name": "Color",
                  "members": {
                    "r": { "type": "Literal", "value": 0 },
                    "g": { "type": "Literal", "value": 255 },
                    "b": { "type": "Literal", "value": 0 }
                  }
                }
              },
              {
                "type": "Call",
                "caller": {
                  "type": "Get",
                  "caller": { "type": "Var", "name": "Canvas" },
                  "property": "fill",
                  "isExpr": false
                },
                "args": [
                  {
                    "type": "Get",
                    "caller": { "type": "Var", "name": "cell" },
                    "property": "x",
                    "isExpr": false
                  },
                  {
                    "type": "Get",
                    "caller": { "type": "Var", "name": "cell" },
                    "property": "y",
                    "isExpr": false
                  }
                ]
              },
              {
                "type": "Call",
                "caller": { "type": "Var", "name": "ink" },
                "args": [
                  {
                    "type": "Call",
                    "caller": {
                      "type": "Get",
                      "caller": { "type": "Var", "name": "Canvas" },
                      "property": "get",
                      "isExpr": false
                    },
                    "args": [
                      {
                        "type": "Get",
                        "caller": { "type": "Var", "name": "cell" },
                        "property": "x",
                        "isExpr": false
                      },
                      {
                        "type": "Get",
                        "caller": { "type": "Var", "name": "cell" },
                        "property": "y",
                        "isExpr": false
                      }
                    ]
                  }
                ]
              }
            ],
            "otherwise": [
              {
                "type": "Conditional",
                "condition": { "type": "Literal", "value": true },
                "body": [
                  {
                    "type": "Call",
                    "caller": {
                      "type": "Get",
                      "caller": { "type": "Var", "name": "Canvas" },
                      "property": "erase",
                      "isExpr": false
                    },
                    "args": [
                      {
                        "type": "Get",
                        "caller": { "type": "Var", "name": "cell" },
                        "property": "x",
                        "isExpr": false
                      },
                      {
                        "type": "Get",
                        "caller": { "type": "Var", "name": "cell" },
                        "property": "y",
                        "isExpr": false
                      }
                    ]
                  },
                  {
                    "type": "Call",
                    "caller": { "type": "Var", "name": "ink" },
                    "args": [
                      {
                        "type": "Call",
                        "caller": {
                          "type": "Get",
                          "caller": { "type": "Var", "name": "Canvas" },
                          "property": "get",
                          "isExpr": false
                        },
                        "args": [
                          {
                            "type": "Get",
                            "caller": { "type": "Var", "name": "cell" },
                            "property": "x",
                            "isExpr": false
                          },
                          {
                            "type": "Get",
                            "caller": { "type": "Var", "name": "cell" },
                            "property": "y",
                            "isExpr": false
                          }
                        ]
                      }
                    ]
                  }
                ],
                "otherwise": []
              }
            ]
          }
        ]
      }
    ]
  },
  {
    "type": "Call",
    "caller": { "type": "Var", "name": "painting" },
    "args": []
  }
]
```
</details>

Awesome! We've got a parser working. Clap yourself on the back - that wasn't so hard, was it?

That was definitely longer than writing a lexer, for sure, but rev up - we're going to see our programming language in action in the next part!

*The complete code here is at [parser.js](https://github.com/hackclub/langjam/blob/main/easel/parser.js).*